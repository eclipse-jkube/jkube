[[groovy-scenario]]
== Using Groovy Configuration

If the <<zero-config-scenario, zero configuration>> mode doesn't fit your use case, and you want more
flexibility, you can also use {plugin} Groovy configuration to configure
plugin as per your needs.
{plugin} provides a rich set of configuration in form of Groovy DSL which
can be used to tune plugin's output as per your specific requirements.

The plugin configuration can be roughly divided into the following sections:

* Global configuration options are responsible for tuning the behavior of plugin tasks.
* `images` defines which container <<config-image, images>> are used and configured.
* `resources` defines the resource descriptors for deploying on {cluster} cluster.
* `enricher` configures various aspects of creating and enhancing resource descriptors.

A working example can be found in https://github.com/eclipse/jkube/tree/master/quickstarts/gradle/groovy-dsl-config[`quickstarts/gradle/groovy-dsl-config`] directory.

[[groovy-scenario-image]]
=== Configuring Images

This section provides an overview of `images` element with which you can configure different aspects of container images generated by {plugin}.
Here is an example of providing Groovy DSL configuration for a simple image:

.Example for providing image using Groovy DSL configuration
[source,groovy,subs="attributes+"]
----
{pluginExtension} {
    images {
        image {
            name = "jkube/${project.name}:${project.version}" //<1>
            alias = "camel-service" //<2>
            build {
                from = "quay.io/jkube/jkube-java:0.0.13" //<3>
                assembly { //<4>
                    targetDir = "/deployments" //<5>
                    layers = [{ //<6>
                        fileSets = [{ //<7>
                            directory = file("${project.rootDir}/build/dependencies")
                       }]
                    }]
                }
                env { //<8>
                    JAVA_LIB_DIR = "/deployments/dependencies/*"
                    JAVA_MAIN_CLASS = "org.apache.camel.cdi.Main"
                }
                labels { //<9>
                    labelWithValue = "foo"
                    version = "${project.version}"
                    artifactId = "${project.name}"
                }
                ports = ["8787"] //<10>
            }
        }
    }
}
----

<1> Name with which we want our image to be built; See `name` field in <<config-image, Image Configuration>> for details.
<2> Shortcut name for image; See `alias` field in <<config-image, Image Configuration>> for details.
<3> Base image on which this image would be built upon; See `from` field in <<config-image-build, Image Build Configuration>> for more details.
<4> Assembly Configuration for copying files/directories into image.
See <<config-image-build-assembly, Assembly Configuration>> for more details.
<5> Target directory inside image for copying a directory into image
<6> Assembly layer; See <<build-assembly-layer, Assembly Inline/Layer Configuration>> for details.
<7> FileSet Assembly Configuraton for copying directories.
See `fileSets` field in <<build-assembly-layer, Assembly Layer Configuration>> for details.
<8> Environment variables added to image.
See <<misc-env, Environment and Labels>> for details.
<9> Labels added to image.
See <<misc-env, Environment and Labels>> for details.
<10> Ports to be exposed.
See `port` field in <<config-image-build, Image Build Configuration>> for details.

You can read more about supported fields in `image` configuration element in <<config-image, Image Configuration>> section.

[[groovy-scenario-image-copy-files]]
=== Copying Files/Directories into Image

If you want to copy some files/directories into your image.
You can make use of {plugin} <<config-image-build-assembly, Assembly Configuration>>.
You would need to provide `assembly` element in `image` > `build`.

Here is an example of copying a single jar file into image.
This configuration would copy a jar file located in `build/libs/` to  `/deployments` folder inside the image:

.Example for copying a file to image using Groovy DSL configuration:
[source,groovy,subs="attributes+"]
----
{pluginExtension} {
    images {
        image {
            name = "${project.group}/${project.name}:${project.version}"
            build {
                from = "quay.io/jkube/jkube-java:0.0.13"
                assembly {
                    targetDir = "/deployments"
                    layers = [{
                        id = "custom-assembly-for-copying-file"
                        files = [{
                            source = file("build/libs/${project.name}-${project.version}-all.jar")
                            outputDirectory = "."
                        }]
                    }]
                }
            }
        }
    }
}
----

In order to copy directories, you would be using `fileSets` configuration element instead of `files`.
Here is an example of copying directories.
This example would copy `build/dependencies` directory to `/deployments` directory inside image.

.Example for copying a directory to image using Groovy DSL configuration:
[source,groovy,subs="attributes+"]
----
{pluginExtension} {
    images {
        image {
            name = "${project.group}/${project.name}:${project.version}"
            build {
                from = "quay.io/jkube/jkube-java:0.0.13"
                assembly {
                    targetDir = "/deployments"
                    layers = [{
                        id = "custom-assembly-for-copying-directory"
                        fileSets = [{
                            directory = file("${project.rootDir}/build/dependencies")
                       }]
                    }]
                }
            }
        }
    }
}
----

=== Kubernetes Labels and Annotations
Refer to <<labels-annotation-configuration, Labels/Annotations Configuration>> in Kubernetes Resource Configuration

=== Kubernetes Controller Generation
Refer to <<resource-controller-generation, Kubernetes Controller Resource Generation>> in Kubernetes Resource Configuration

=== Kubernetes Ingress Generation
Refer to <<ingress-generation, Ingress Generation>> in Kubernetes Resource Configuration

=== Kubernetes ServiceAccount Generation
Refer to <<serviceaccount-generation, ServiceAccount Generation>> in Kubernetes Resource Configuration

ifeval::["{task-prefix}" == "oc"]
include::{kitdoc-path}/inc/route-generation/_route_generation.adoc[]
endif::[]
