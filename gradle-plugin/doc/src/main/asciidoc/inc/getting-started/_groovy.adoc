[[groovy-scenario]]
== Using Groovy Configuration

If the <<zero-config-scenario, zero configuration>> mode doesn't fit your use case, and you want more
flexibility, you can also use {plugin} Groovy configuration to configure
plugin as per your needs.
{plugin} provides a rich set of configuration in form of Groovy DSL which
can be used to tune plugin's output as per your specific requirements.

The plugin configuration can be roughly divided into the following sections:

* Global configuration options are responsible for tuning the behavior of plugin tasks.
* `images` defines which container <<config-image, images>> are used and configured.
* `resources` defines the resource descriptors for deploying on {cluster} cluster.
* `enricher` configures various aspects of creating and enhancing resource descriptors.

A working example can be found in https://github.com/eclipse/jkube/tree/master/quickstarts/gradle/groovy-dsl-config[`quickstarts/gradle/groovy-dsl-config`] directory.

[[groovy-scenario-image]]
=== Configuring Images

This section provides an overview of `images` element with which you can configure different aspects of container images generated by {plugin}.
Here is an example of providing Groovy DSL configuration for a simple image:

.Example for providing image using Groovy DSL configuration
[source,groovy,subs="attributes+"]
----
{pluginExtension} {
    images {
        image {
            name = "jkube/${project.name}:${project.version}" //<1>
            alias = "camel-service" //<2>
            build {
                from = "quay.io/jkube/jkube-java-binary-s2i:0.0.9" //<3>
                assembly { //<4>
                    targetDir = "/deployments" //<5>
                    layers = [{ //<6>
                        fileSets = [{ //<7>
                            directory = file("${project.rootDir}/build/dependencies")
                       }]
                    }]
                }
                env { //<8>
                    JAVA_LIB_DIR = "/deployments/dependencies/*"
                    JAVA_MAIN_CLASS = "org.apache.camel.cdi.Main"
                }
                labels { //<9>
                    labelWithValue = "foo"
                    version = "${project.version}"
                    artifactId = "${project.name}"
                }
                ports = ["8787"] //<10>
            }
        }
    }
}
----

<1> Name with which we want our image to be built; See `name` field in <<config-image, Image Configuration>> for details.
<2> Shortcut name for image; See `alias` field in <<config-image, Image Configuration>> for details.
<3> Base image on which this image would be built upon; See `from` field in <<config-image-build, Image Build Configuration>> for more details.
<4> Assembly Configuration for copying files/directories into image.
See <<config-image-build-assembly, Assembly Configuration>> for more details.
<5> Target directory inside image for copying a directory into image
<6> Assembly layer; See <<build-assembly-layer, Assembly Inline/Layer Configuration>> for details.
<7> FileSet Assembly Configuraton for copying directories.
See `fileSets` field in <<build-assembly-layer, Assembly Layer Configuration>> for details.
<8> Environment variables added to image.
See <<misc-env, Environment and Labels>> for details.
<9> Labels added to image.
See <<misc-env, Environment and Labels>> for details.
<10> Ports to be exposed.
See `port` field in <<config-image-build, Image Build Configuration>> for details.

You can read more about supported fields in `image` configuration element in <<config-image, Image Configuration>> section.

[[groovy-scenario-image-copy-files]]
==== Copying Files/Directories into Image

If you want to copy some files/directories into your image.
You can make use of {plugin} <<config-image-build-assembly, Assembly Configuration>>.
You would need to provide `assembly` element in `image` > `build`.

Here is an example of copying a single jar file into image.
This configuration would copy a jar file located in `build/libs/` to  `/deployments` folder inside the image:

.Example for copying a file to image using Groovy DSL configuration:
[source,groovy,subs="attributes+"]
----
{pluginExtension} {
    images {
        image {
            name = "${project.group}/${project.name}:${project.version}"
            build {
                from = "quay.io/jkube/jkube-java-binary-s2i:0.0.9"
                assembly {
                    targetDir = "/deployments"
                    layers = [{
                        id = "custom-assembly-for-copying-file"
                        files = [{
                            source = file("build/libs/${project.name}-${project.version}-all.jar")
                            outputDirectory = "."
                        }]
                    }]
                }
            }
        }
    }
}
----

In order to copy directories, you would be using `fileSets` configuration element instead of `files`.
Here is an example of copying directories.
This example would copy `build/dependencies` directory to `/deployments` directory inside image.

.Example for copying a directory to image using Groovy DSL configuration:
[source,groovy,subs="attributes+"]
----
{pluginExtension} {
    images {
        image {
            name = "${project.group}/${project.name}:${project.version}"
            build {
                from = "quay.io/jkube/jkube-java-binary-s2i:0.0.9"
                assembly {
                    targetDir = "/deployments"
                    layers = [{
                        id = "custom-assembly-for-copying-directory"
                        fileSets = [{
                            directory = file("${project.rootDir}/build/dependencies")
                       }]
                    }]
                }
            }
        }
    }
}
----

[[resource-labels-annotations]]
=== Kubernetes Labels and Annotations

Labels and annotations can be easily added to any resource object.
This is best explained by an example.

.Example for label and annotations
[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
kubernetes {
  resources {
    labels { //<1>
      all { //<2>
        extraLabel = "quickstart-groovy-dsl-configuration"
      }
      service { //<3>
        database = 'mysql'
        persistent = 'true'
      }
      replicaSet { //<4>
        // ...
      }
      pod { //<5>
        // ...
      }
      deployment { //<6>
        // ...
      }
    }
    annotations { //<7>
       // ...
    }
 }
}
----
<1> `labels` section with `resources` contains labels which should be applied to objects of various kinds
<2> Within `all` labels which should be applied to *every* object can be specified
<3> `service` labels are used to label services
<4> `replicaSet` labels are for replica set and replication controller
<5> `pod` holds labels for pod specifications in replication controller, replica sets and deployments
<6> `deployment` is for labels on deployments (kubernetes) and deployment configs (openshift)
<7> The subelements are also available for specifying annotations.

Labels and annotations can be specified in free form as a map.
In this map, the element name is the name of the label or annotation respectively, whereas the content is the value to set.
See <<labels-annotation-configuration, Labels and Annotations Configuration>> for more details.

[[controller-resource-generation]]
=== Kubernetes Controller Generation

In JKube terminology, a Controller resource is a Kubernetes resource which manages Pods created for your application.
These can be one of the following resources:

* https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/[ReplicationController]
* https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/[ReplicaSet]
* https://kubernetes.io/docs/concepts/workloads/controllers/deployment/[Deployment]
* https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/[StatefulSet]
* https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/[DaemonSet]
* https://kubernetes.io/docs/concepts/workloads/controllers/job/[Job]
ifeval::["{task-prefix}" == "oc"]
* https://docs.openshift.com/container-platform/4.7/applications/deployments/what-deployments-are.html#deployments-and-deploymentconfigs_what-deployments-are[DeploymentConfig]
endif::[]

By default Deployment is generated in Kubernetes mode.
You can easily configure different aspects of generated Controller resource using Groovy DSL configuration.
Here is an example:

.Example of Controller Resource Configuration
[source,groovy]
----
kubernetes {
  resources {
    labels {
      all {
        extraLabel = "quickstart-groovy-dsl-configuration"
      }
    }
    env { //<1>
      organization = "Eclipse Foundation"
      projectName = "jkube"
    }
    controllerName = "${project.name}-controller" //<2>
    containerPrivileged = true //<3>
    imagePullPolicy = "Always" //<4>
    replicas = "2" //<5>
    liveness { //<6>
      getUrl = "http://:8080/q/health"
      tcpPort = "8080"
      initialDelaySeconds = "3"
      timeoutSeconds = "3"
    }
    volumes = [{ //<7>
      name = "scratch"
      type = "emptyDir"
      medium = "Memory"
      mounts = ["/var/scratch"]
    }]
  }
}
----

<1> Environment variables added to all of your application Pods
<2> Name of Controller(`metadata.name` set in generated Deployment, Job, ReplicaSet etc)
<3> Setting https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod[Security Context] of all application Pods.
<4> Configure how images would be updated. Can be one of `IfNotPresent`, `Always` or `Never`. Read https://kubernetes.io/docs/concepts/containers/images/#updating-images[Kubernetes Images docs] for more details.
<5> Number of replicas of pods we want to have in our application
<6> Define an HTTP liveness request, see https://kubernetes.io/docs/concepts/containers/images/#updating-images[Kubernetes Liveness/Readiness probes] for more details.
<7> Mounting an EmptyDir Volume to your application pods

See <<controller-resource-groovy-configuration, Kubernetes Controller Configuration>> for more details.

[[ingress-generation]]
=== Ingress Generation

Once you've enabled `jkube.createExternalUrls` property, you should be able to generate an opinionated ingress during {task-prefix}Resource task. You can also configure it as per your needs using Groovy DSL configuration or by providing your own resource fragments.

Here is an example of configuring Ingress using Groovy DSL configuration:

.Enable Ingress Generation by enabling createExternalUrl property
[source,properties]
----
jkube.createExternalUrls = true
----

Services which are exposed by Ingress should also contain `expose = true` label. If not, you can configure plugin to expose them like this:
.Example for exposing Service for Ingress
[source,groovy]
----
kubernetes {
    enricher {
        config {
            "jkube-service" {
                expose = "true"
            }
        }
    }
}
----


.Example for Ingress Configuration
[source,groovy]
----
kubernetes {
  resources {
    ingress {
      ingressTlsConfigs = [{ //<1>
        hosts = ["foo.bar.com"]
        secretName = "testsecret-tls"
      }]
      ingressRules = [{
        host = "foo.bar.com" //<2>
        paths = [{
          pathType = "Prefix" //<3>
          path = "/foo" //<4>
          serviceName = "service1" //<5>
          servicePort = "8080" //<6>
        }]
      }]
    }
  }
}
----

<1> https://kubernetes.io/docs/concepts/services-networking/ingress/#tls[Ingress TLS] Configuration to specify Secret that contains TLS private key and certificate
<2> Host names, can be precise matches or a wildcard. See https://kubernetes.io/docs/concepts/services-networking/ingress/#hostname-wildcards[Kubernetes Ingress Hostname] documentation for more details
<3> https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types[Ingress Path Type], Can be one of `ImplementationSpecific`, `Exact` or `Prefix`
<4> Ingress path corresponding to provided `service.name`
<5> Service Name corresponding to path
<6> Service Port corresponding to path

For more information, please see <<ingress-groovy-configuration, Ingress Configuration>>.

You can create Ingress using yaml fragment also. You would need to place a fragment of yaml in `src/main/jkube` directory like this:

.Ingress fragment Example
[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-example-ingress
spec:
  tls:
  - hosts:
    - https-example.foo.com
    secretName: testsecret-tls
  rules:
  - host: https-example.foo.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: service1
            port:
              number: 80
----

[[serviceaccount-generation]]
=== ServiceAccount Generation

You can configure `resources` configuration to generate a ServiceAccount or configure an already existing ServiceAccount into your generated Deployment.

Here is an example of Groovy DSL configuration to generate a ServiceAccount:

.Example for Creating ServiceAccount via Groovy DSL
[source,groovy]
----
kubernetes {
  resources {
    serviceAccounts = [{
      name = "my-serviceaccount" //<1>
      deploymentRef = "my-deployment-name" //<2>
    }]
  }
}
----
<1> Name of ServiceAccount to be created
<2> Deployment which will be using this ServiceAccount

If you don't want to generate ServiceAccount but just use an existing ServiceAccount in your Deployment. You can configure it via `serviceAccount` field in resource configuration. Here is an example:

.Example for Configuring already existing ServiceAccount into generated Deployment
[source,groovy]
----
kubernetes {
  resources {
    serviceAccount = "my-existing-serviceaccount"
  }
}
----

**Service Account Resource fragment**:

If you don't want to use Groovy DSL configuration, you can provide a resource fragment for ServiceAccount resource. Here is how it would look like:

.ServiceAccount resource fragment
[source,yaml]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: build-robot
----
